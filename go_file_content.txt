--- Folder Structure ---
.
app/
app/api/
app/api/get_subs/
  route.ts
  globals.css
  layout.tsx
  page.tsx
  generate_llm.js
  next-env.d.ts
  next.config.ts
public/

--- route.ts ---
import { NextResponse } from "next/server";
import { createRequire } from "module";
import path from "path";
import fs from "fs";

const require = createRequire(import.meta.url);
const youtubedl = require("youtube-dl-exec");

const DOWNLOAD_DIR = path.join(process.cwd(), "downloads");

export async function POST(req: Request) {
  try {
    const { youtubeUrl } = await req.json();
    if (!youtubeUrl) {
      return NextResponse.json(
        { error: "No YouTube URL provided" },
        { status: 400 }
      );
    }

    if (!fs.existsSync(DOWNLOAD_DIR)) {
      fs.mkdirSync(DOWNLOAD_DIR, { recursive: true });
    }

    // Run yt-dlp via youtube-dl-exec
    await youtubedl(youtubeUrl, {
      writeAutoSub: true,
      writeSub: true,
      subLang: "en",
      skipDownload: true,
      output: path.join(DOWNLOAD_DIR, "temp_%(id)s"),
    });

    const files = fs
      .readdirSync(DOWNLOAD_DIR)
      .filter((f) => f.endsWith(".vtt"));
    if (files.length === 0) {
      return NextResponse.json(
        { error: "No subtitles found" },
        { status: 404 }
      );
    }

    const subtitlePath = path.join(DOWNLOAD_DIR, files[0]);
    const subtitles = fs.readFileSync(subtitlePath, "utf-8");

    return NextResponse.json({ subtitles });
  } catch (err: any) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}


--- globals.css ---
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}


--- layout.tsx ---
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


--- page.tsx ---
"use client";

import { useState } from "react";
import ReactMarkdown from "react-markdown";
import styles from "./page.module.css";

export default function HomePage() {
  const [url, setUrl] = useState("");
  const [subtitles, setSubtitles] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError("");
    setSubtitles("");

    try {
      const res = await fetch("/api/get-subs", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ youtubeUrl: url }),
      });

      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Failed to fetch subtitles");

      setSubtitles(cleanVTT(data.subtitles));
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  // Clean VTT function
  function cleanVTT(vtt: string) {
    let text = vtt
      .replace(/WEBVTT.*\n/g, "")
      .replace(/Kind:.*\n/g, "")
      .replace(/Language:.*\n/g, "")
      .replace(/<c>/g, "")
      .replace(/<\/c>/g, "")
      .replace(/<\d{2}:\d{2}:\d{2}\.\d{3}>/g, "")
      .replace(/\s+/g, " ")
      .trim();
    return text;
  }

  return (
    <main className={styles.container}>
      <h1 className={styles.title}>YouTube Subtitle Extractor</h1>

      <form onSubmit={handleSubmit} className={styles.form}>
        <input
          type="text"
          placeholder="Enter YouTube URL"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          className={styles.input}
        />
        <button type="submit" disabled={loading} className={styles.button}>
          {loading ? "Fetching..." : "Get Subtitles"}
        </button>
      </form>

      {error && <p className={styles.error}>{error}</p>}

      {subtitles && (
        <div className={styles.subtitleBox}>
          <ReactMarkdown>{subtitles}</ReactMarkdown>
        </div>
      )}
    </main>
  );
}


--- generate_llm.js ---
const fs = require("fs");
const path = require("path");

function generateGoFileContentText(
  projectPath,
  outputFile = "go_file_content.txt"
) {
  const excludeDirs = ["vendor", ".git", "node_modules", ".next"];
  const outputStream = fs.createWriteStream(outputFile, { encoding: "utf8" });

  outputStream.write("--- Folder Structure ---\n");

  function walkDir(dir, relativePath = ".") {
    const files = fs.readdirSync(dir, { withFileTypes: true });

    const displayPath = relativePath === "." ? "." : `${relativePath}/`;
    outputStream.write(displayPath + "\n");

    for (const file of files) {
      const fullPath = path.join(dir, file.name);
      const subPath = path.join(relativePath, file.name);

      if (file.isDirectory()) {
        if (excludeDirs.some((exclude) => fullPath.includes(exclude))) continue;
        walkDir(fullPath, subPath);
      } else if (
        file.isFile() &&
        [".js", ".jsx", ".css", ".html", ".local", ".ts", ".tsx"].some((ext) =>
          file.name.endsWith(ext)
        )
      ) {
        outputStream.write(`  ${file.name}\n`);
      }
    }
  }

  function writeGoFileContents(dir) {
    const files = fs.readdirSync(dir, { withFileTypes: true });

    for (const file of files) {
      const fullPath = path.join(dir, file.name);

      if (file.isDirectory()) {
        if (excludeDirs.some((exclude) => fullPath.includes(exclude))) continue;
        writeGoFileContents(fullPath);
      } else if (
        file.isFile() &&
        [".js", ".jsx", ".css", ".html", ".local", ".ts", ".tsx"].some((ext) =>
          file.name.endsWith(ext)
        )
      ) {
        outputStream.write(`--- ${file.name} ---\n`);
        try {
          const content = fs.readFileSync(fullPath, "utf8");
          outputStream.write(content + "\n\n");
        } catch (err) {
          outputStream.write(`Error reading file: ${err.message}\n\n`);
        }
      }
    }
  }

  walkDir(projectPath);
  outputStream.write("\n");
  writeGoFileContents(projectPath);
  outputStream.end(() => {
    console.log(`Go file content generated in '${outputFile}'`);
  });
}

// Replace with your actual path if needed
const projectPath = "./";
generateGoFileContentText(projectPath);


--- next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference path="./.next/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


--- next.config.ts ---
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


